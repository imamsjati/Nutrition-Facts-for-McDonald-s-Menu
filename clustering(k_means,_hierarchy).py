# -*- coding: utf-8 -*-
"""Clustering(K-Means, Hierarchy).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16iHRvaUyWJ_Ld-kgVozx6nizyh3XXouQ

## **DTS Data Science** 
# Institut Teknologi Sepuluh Nopember (Kelas B)

## **Challenge 2** - Clustering

## **Nutrition Facts for McDonald's Menu**

**Introduction**

Ray Kroc ingin membangun sistem restoran yang terkenal akan penyediaan makanan dengan kualitas tinggi dan metode persiapan yang seragam. Dia ingin menyajikan burger, roti, kentang goreng, dan minuman yang rasanya sama di Alaska seperti di Alabama. Untuk mencapai ini, dia memilih jalan yang unik: membujuk baik pemegang waralaba dan pemasok untuk membeli visinya, bekerja bukan untuk McDonald's tetapi untuk diri mereka sendiri, bersama dengan McDonald's. Banyak item menu paling terkenal McDonald's - Seperti Big Mac, Filet-O-Fish, dan Egg McMuffin dibuat oleh franchisee

**Nutrition Facts for McDonald's Menu Dataset** memberikan analisis nutrisi untuk setiap item menu di menu McDonald's AS, termasuk menu sarapan, burger daging sapi, sandwich ayam dan ikan, kentang goreng, salad, soda, kopi dan teh, milkshake, dan makanan penutup.

## Data Acquisition

Melakukan import library yang diperlukan
"""

# Commented out IPython magic to ensure Python compatibility.
import random 
import numpy as np 
import pandas as pd
import matplotlib.pyplot as plt 
import seaborn as sns
from sklearn.cluster import KMeans 
from sklearn.datasets.samples_generator import make_blobs 
# %matplotlib inline
from scipy import ndimage 
from scipy.cluster import hierarchy 
from scipy.spatial import distance_matrix 
from sklearn import manifold, datasets 
from sklearn.cluster import AgglomerativeClustering 
from sklearn.datasets.samples_generator import make_blobs 
# %matplotlib inline

"""Import Data Set"""

from google.colab import files
data_to_load = files.upload()

import io
mcdata = pd.read_csv(io.BytesIO(data_to_load['menu.csv']))
mcdata

"""Berdasarkan tabel di atas, kami memiliki beberapa fitur yang menjelaskan fakta nutrisi dari semua item di menu. Mari kita lihat apakah ada nilai null dan apakah semua tipe data fitur sudah benar?

## Data Exploration

Pengecekan data
"""

mcdata.info()

"""Dari informasi di atas, dapat diketahui bilamana ada tiga kolom data yang bertipe data bukan integer ataupun float. Sehingga perlu dilakukan perubahan tipe data dan atau penghapusan kolom yang bersangkutan.

Mencari korelasi data tiap fitur
"""

dg = mcdata.drop(['Serving Size','Category','Item'], axis=1)
dz = dg.corr()
dz

plt.figure(figsize=(10,10))
sns.heatmap(dz, cmap='Blues', annot=True,)
plt.show()

"""Dari heat map di atas, dapat kita ketahui bahwa Fat memiliki korelasi paling tinggi dengan kalori, diikuti oleh protein pada urutan kedua (0.79) dan pada urutan ketiga, karbohidrat (0.78). Selain itu korelasi dengan kalori, ada korelasi yang tinggi dengan fitur lain, misalnya sodium dan iron (0.87), sodium dengan protein (0.87), dan sodium dengan kalori (0.71)

# Klasterisasi dengan menggunakan K-Means

K-Means Clustering adalah suatu metode penganalisaan data atau metode Data Mining yang melakukan proses pemodelan dengan pengelompokan data menggunakan sistem partisi.
Terdapat dua jenis data clustering yang sering dipergunakan dalam proses pengelompokan data yaitu Hierarchical dan Non-Hierarchical, dan K-Means merupakan salah satu metode data clustering non-hierarchical atau Partitional Clustering. 

Untuk memproses data algoritma K-means Clustering , data dimulai dengan kelompok pertama centroid yang dipilih secara acak, yang digunakan sebagai titik awal untuk setiap cluster, dan kemudian melakukan perhitungan berulang (berulang) untuk mengoptimalkan posisi centroid.
"""

df = mcdata.drop(['Serving Size'], axis=1)
#df = mcdata.drop(['Serving Size','Category','Item'], axis=1)
#,'Total Fat','Saturated Fat','Trans Fat'
df

"""Normalisasi dan perubahan data frame menjadi array"""

from sklearn.preprocessing import StandardScaler
X = df.values[:,2:]
X = np.nan_to_num(X)
Clus_dataSet = StandardScaler().fit_transform(X)
Clus_dataSet

"""Setelah itu, kita akan menentukan jumlah klasternya, misalnya disini kita memilih 3 klaster. Jumlah klaster ini bebas tergantung peneliti."""

clusterNum = 3
k_means = KMeans(init = "k-means++", n_clusters = clusterNum, n_init = 12)
k_means.fit(X)
labels = k_means.labels_
print(labels)

df["Clus_km"] = labels
df.head(5)

df.groupby('Clus_km').mean()

"""Dari tabel di atas, dapat diketahui bahwa ketika dilihat dari sisi 'calories', data dikelompokkan menjadi menu yang memiliki jumlah kalori besar (0), sedang (1), dan kecil (3)."""

area = np.pi*( X[:, 0])**2
area

"""Di sini kami mencoba untuk menampilkan hasil clustering dalam bentuk scatter plot dilihat dari sisi Calories dan Sodium."""

lt.scatter(X[:, 0], X[:, 10], c=labels.astype(np.float), alpha=0.5)
plt.xlabel('Calories', fontsize=18)
plt.ylabel('Sodium', fontsize=16)

plt.show()

"""Dari scatter plot di atas dapat dilihat persebaran dari ketiga cluster, di mana terdapat satu outlier pada cluster ketiga (2) dengan jumlah kalori dan sodium tinggi."""

mcd_dat = df.groupby('Clus_km').count()
mcd_dat

agg_mcdata = df.groupby(['Clus_km'])['Calories','Sodium'].count()
agg_mcdata

"""Dari tabel di atas, dapat diketahui jumlah item yang berada pada masing-masing cluster, di mana cluster 1 (kandungan Calories dan Sodium rendah)

# Klasterisasi dengan menggunakan Hierarki

Dalam metode hirarki cluster terdapat dua tipe dasar yaitu agglomerative (pemusatan) dan divisive (penyebaran). Dalam metode agglomerative, setiap obyek atau observasi dianggap sebagai sebuah cluster tersendiri. Dalam tahap selanjutnya, dua cluster yang mempunyai kemiripan digabungkan menjadi sebuah cluster baru demikian seterusnya. Sebaliknya, dalam metode divisive kita beranjak dari sebuah cluster besar yang terdiri dari semua obyek atau observasi. Selanjutnya, obyek atau observasi yang paling tinggi nilai ketidakmiripannya kita pisahkan demikian seterusnya (B.J, 2009).

Fitur yang akan digunakan dalam metodi ini adalah ['Calories', 'Calories from Fat','Total Fat', 'Total Fat (% Daily Value)', 'Saturated Fat','Saturated Fat (% Daily Value)', 'Trans Fat', 'Cholesterol','Cholesterol (% Daily Value)', 'Sodium', 'Sodium (% Daily Value)','Carbohydrates', 'Carbohydrates (% Daily Value)', 'Dietary Fiber','Dietary Fiber (% Daily Value)', 'Sugars', 'Protein','Vitamin A (% Daily Value)', 'Vitamin C (% Daily Value)','Calcium (% Daily Value)', 'Iron (% Daily Value)'] sebagai representasi dari nutrisi dalam menu.
"""

featureset = mcdata.drop(['Serving Size','Category','Item'], axis=1)
featureset

"""Data dalam fitur yang telah dipilih dinormaslisasi menggunakan MinMaxScaler dengan nilai rentang antara 0-1 sehingga sebaran data tidak acak atau inkonsisten data dikarenakan tiap data dalam fitur tersebut memiliki rentang berbeda. """

from sklearn.preprocessing import MinMaxScaler
x = featureset.values #returns a numpy array
min_max_scaler = MinMaxScaler()
feature_mtx = min_max_scaler.fit_transform(x)
feature_mtx [0:5]

"""Dengan menggunakan Scipy dataset dikumpulkan dan menghitung jarak antar matrix."""

import scipy
leng = feature_mtx.shape[0]
D = scipy.zeros([leng,leng])
for i in range(leng):
    for j in range(leng):
        D[i,j] = scipy.spatial.distance.euclidean(feature_mtx[i], feature_mtx[j])

import pylab
import scipy.cluster.hierarchy
Z = hierarchy.linkage(D, 'complete')

from scipy.cluster.hierarchy import fcluster
max_d = 3
clusters = fcluster(Z, max_d, criterion='distance')
clusters

"""Menentukan banyaknya jumlah kluster sebanyak 3 secara langsung"""

from scipy.cluster.hierarchy import fcluster
k = 3
clusters = fcluster(Z, k, criterion='maxclust')
clusters

"""Visualisasi dendogram hasil klusterisasi berdasarkan nilai kalori dan sodium pada setiap item menu."""

fig = pylab.figure(figsize=(18,50))
def llf(id):
    return '[%s %s %s]' % (mcdata['Item'][id], mcdata['Calories'][id], int(float(mcdata['Sodium'][id])) )
    
dendro = hierarchy.dendrogram(Z,  leaf_label_func=llf, leaf_rotation=0, leaf_font_size =12, orientation = 'right')

"""Hierarchical Clustering dapat divisualisasikan ke dalam bentuk dendogram. Hasilnya didapati bahwa beberapa item menu yang memiliki kesamaan atau kemiripan pada nilai kalori dan sodium akan diklusterkan menjadi satu.

Hierarchical Clustering juga dapat dilakukan dengan menggunakan library sckit-learn.
"""

dist_matrix = distance_matrix(feature_mtx,feature_mtx) 
print(dist_matrix)

"""AgglomerativeClustering melakukan pengelompokan hierarkis menggunakan pendekatan bottom-up. Kriteria keterkaitan menentukan metrik yang digunakan untuk strategi penggabungan."""

agglom = AgglomerativeClustering(n_clusters = 3, linkage = 'complete')
agglom.fit(feature_mtx)
agglom.labels_

"""Menambahkan field baru ke dalam dataframe yang merupakan hasil dari klusterisasi pada kolom "cluster_ "."""

mcdata['cluster_'] = agglom.labels_
mcdata.head()

import matplotlib.cm as cm
n_clusters = max(agglom.labels_)+1
colors = cm.rainbow(np.linspace(0, 1, n_clusters))
cluster_labels = list(range(0, n_clusters))

# Create a figure of size 6 inches by 4 inches.
plt.figure(figsize=(16,14))

for color, label in zip(colors, cluster_labels):
    subset = mcdata[mcdata.cluster_ == label]
    for i in subset.index:
            plt.text(subset.Calories[i], subset.Sodium[i],str(subset['Category'][i]), rotation=25) 
    plt.scatter(subset.Calories, subset.Sodium, s=100, c=color, label='cluster'+str(label),alpha=0.5)       
#    plt.scatter(subset.Calories, subset.Sodium, s= subset.price*10, c=color, label='cluster'+str(label),alpha=0.5)
#    plt.scatter(subset.Calories, subset.Sodium)
plt.legend()
plt.title('Clusters')
plt.xlabel('Calories')
plt.ylabel('Sodium')

"""Distribusi setiap kluster dapat dilihat melalui scatter plot"""

mcdata.groupby(['cluster_','Category'])['cluster_'].count()

mcdata.groupby(['cluster_'])['cluster_'].count()

"""Dari hasil klasterisasi diketahui bahwa Klaster[0] terdiri dari 15 item menu, Klaster[1] terdiri dari 229 item menu, dan Klaster[2] terdiri dari 156item menu."""

agg_mcdata = mcdata.groupby(['cluster_'])['Calories','Sodium'].mean()
agg_mcdata

"""Untuk klasterisasi menu tersebut dapat disimpulkan bahwa Klaster[0] memiliki tingkat kalori tinggi dan sodium tinggi, Klaster[1] memiliki tingkat kalori rendah dan sodium tsedang, dan Klaster[2] memiliki tingkat kalori sedang dan sodium rendah,"""

